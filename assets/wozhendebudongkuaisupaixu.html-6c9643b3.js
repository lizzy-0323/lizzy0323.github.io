import { _ as _export_sfc, o as openBlock, c as createElementBlock, e as createStaticVNode } from "./app-657f6655.js";
const _sfc_main = {};
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _cache[0] || (_cache[0] = [
    createStaticVNode('<h1 id="我真的不懂快速排序" tabindex="-1"><a class="header-anchor" href="#我真的不懂快速排序" aria-hidden="true">#</a> 我真的不懂快速排序</h1><pre><code>稍微标题党一下，出于个人感慨~，而非刻意为之\n</code></pre><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>如标题所示，在近期的吹逼当中，我忽然发现完完全全的手写一个快排对我来说并不是一个多容易的事情，更别说快排背后的原理，以及之前没思考过的partition算法了，因此准备写一篇博客来记录一下关于快排的七七八八。</p><h2 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序" aria-hidden="true">#</a> 快速排序</h2><p>快速排序(quick sort)是一种基于分治策略的算法，算法的平均时间复杂度是O(nlogn)，这个在大二的时候已经接触过了。</p><p>从策略上讲，他主要采用了一种<strong>分治</strong>策略来实现了<strong>快速</strong>,核心操作是<strong>哨兵划分</strong>，操作如下：</p><ol><li>每次选择一个元素作为哨兵节点</li><li>将所有小于它的元素移到左侧，所有大于它的元素移到右侧，</li><li>递归的进行该操作，直到当前数组长度为1 显然，我们知道快速排序的平均时间复杂度，然而，对于它的最差时间复杂度，依旧是可以达到O(n^2)，对于快速排序而言，时间性能取决于递归的深度最坏情况：当数组已经逆序，或者有序排好的时候，每次进行递归，左侧二叉树是0个元素，右侧是n-1个元素，显然递归深度非常高，最坏情况并不比其他的排序效果好。 最好情况：如果每次都是平衡的去划分，形成一个平衡的完全二叉树，那么显然可以做到复杂度为O(nlogn)</li></ol><h2 id="如何选择哨兵节点" tabindex="-1"><a class="header-anchor" href="#如何选择哨兵节点" aria-hidden="true">#</a> 如何选择哨兵节点</h2><p>刚刚提到，快速排序需要选择哨兵节点，并且移动哨兵节点两侧的节点，那么该如何选择哨兵节点，使得两侧的元素个数差不多呢？ 这里提供几种方法。</p><h3 id="hoare分区法" tabindex="-1"><a class="header-anchor" href="#hoare分区法" aria-hidden="true">#</a> Hoare分区法</h3><p>这也是最常见的分区方法，同时也是坐着Hoare自己提出的分区法。</p><ol><li>先从序列中随机选一个pivot，默认从最左边元素</li><li>将两个索引 i 和 j 分别从左右两边开始往中间遍历</li><li>先让 j 从后往前找到第一个 &lt; v 的元素停止，把这个元素直接赋值给i所对应得元素。</li><li>再让 i 从前往后找到第一个 &gt; v 的元素停止</li><li>当 i 和 j 重合时，arr[i] = pivot 即可 用代码描述如下所示，这里把partition和sort写在了一起：</li></ol><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">quicksort</span><span class="token punctuation">(</span>lst<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    <span class="token keyword">if</span> start <span class="token operator">&gt;</span> end<span class="token punctuation">:</span>\n        <span class="token keyword">return</span>\n    l<span class="token punctuation">,</span> r <span class="token operator">=</span> start<span class="token punctuation">,</span> end\n    pivot <span class="token operator">=</span> lst<span class="token punctuation">[</span>start<span class="token punctuation">]</span>\n    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>\n        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token keyword">and</span> pivot <span class="token operator">&lt;=</span> lst<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>\n            r <span class="token operator">-=</span> <span class="token number">1</span>\n        lst<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> lst<span class="token punctuation">[</span>r<span class="token punctuation">]</span>\n        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token keyword">and</span> pivot <span class="token operator">&gt;</span> lst<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>\n            l <span class="token operator">+=</span> <span class="token number">1</span>\n        lst<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> lst<span class="token punctuation">[</span>l<span class="token punctuation">]</span>\n    lst<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> pivot\n    quicksort<span class="token punctuation">(</span>lst<span class="token punctuation">,</span> start<span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>\n    quicksort<span class="token punctuation">(</span>lst<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span>\n<span class="token comment"># print(lst)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说就是左右各有一个指针向内侧移动，每次找到两个不符合标准的元素，就将他们交换，直到i和j移动到同一位置时，把pivot填充进去</p><h3 id="lomuto分区法-快慢指针法" tabindex="-1"><a class="header-anchor" href="#lomuto分区法-快慢指针法" aria-hidden="true">#</a> Lomuto分区法（快慢指针法）</h3><p>它的方法是采用数组中的最后一个元素作为pivot，然后把所有小于枢轴的元素放在枢轴的左边，所有大于枢轴的元素放在枢轴的右边。Lomuto分区只需要一次遍历即可完成。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">quicksort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    <span class="token keyword">if</span> low <span class="token operator">&lt;</span> high<span class="token punctuation">:</span>\n        <span class="token comment"># 找到分区索引</span>\n        pivot_index <span class="token operator">=</span> partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>\n        <span class="token comment"># 对基准左边的子数组进行快速排序</span>\n        quicksort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>\n        <span class="token comment"># 对基准右边的子数组进行快速排序</span>\n        quicksort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span>\n\n\n<span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    <span class="token comment"># 选择最后一个元素作为基准</span>\n    pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span>\n    i <span class="token operator">=</span> low <span class="token operator">-</span> <span class="token number">1</span>\n    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>\n        <span class="token comment"># 如果当前元素小于或等于基准</span>\n        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">:</span>\n            i <span class="token operator">+=</span> <span class="token number">1</span>\n            <span class="token comment"># 交换 arr[i] 和 arr[j]</span>\n            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>\n    <span class="token comment"># 交换基准到它最终的位置</span>\n    arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>\n    <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="两种方案的效率对比" tabindex="-1"><a class="header-anchor" href="#两种方案的效率对比" aria-hidden="true">#</a> 两种方案的效率对比</h3><ul><li>平均情况下，hoare分区策略会得到lomuto三分之一的交换次数</li><li>最坏情况下（已排序），两种分区类似，都是O(n^2)</li><li>如果选择了中间元素作为基准，Hoare分区效果更好</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>快排虽然简单，但是仍有多种优化策略，在现实场景中，pivot的选举尤为重要。</p>', 22)
  ]));
}
const wozhendebudongkuaisupaixu_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "wozhendebudongkuaisupaixu.html.vue"]]);
export {
  wozhendebudongkuaisupaixu_html as default
};
